# Project 2 @ CSC 201 Fall 2025: AVL Tree

## Pledged Work Policy

This is a ___Pledged Work___ assignment.  This means that the work you submit for grading ___must___ be your work product.  
You may not submit the work of others outside of your team, or the modification of work of others outside of your team.
You are encouraged to talk with each other about general problems.  For example, you may talk to someone about "What does it mean when the compiler says there is a semicolon missing on line 20", or "I can not get my assignment template to download from GitHub, what did you do?".  However, you may not engage in "Could you send me a copy of your work so I can see how to get started?".  You may get full and detailed assistance from me, the Teaching Assistant (TA), and the TAs in the Computer Science Center.  If you have any question about the appropriateness of assistance, do not hesitate to consult with me.

Use of ChatGPT or similar resources are encouraged but they must be documented in this README.md. That includes 1) the exact prompt used, 2) the screenshots of the outputs, and 3) your personal assessment on how useful it was. Even erroneous or unuseful results must be documented.

If I believe you have violated our ___Pledge Work___ agreement, I will pursue this matter through the college Honor Council.

## Overview

An AVL Tree is a type of self-balancing Binary Search Tree (BST) that ensures that the tree is approximately balanced. An AVL Tree remains balanced as elements are inserted or deleted. During class, we discussed the general algorithms for a BST and an AVL tree.  In particular, we emphasized how a regular BST structure can become basically a linked list if its balance is not maintained, resulting in a O(N) running time instead of the O(log N) we expect from a properly balanced BST.

In this project, you will:
1. Implement a generic BST with an iterator interface. (You developed this in Project 1, which you can use as is or update.)
2. Implement a generic AVL Tree with an iterator interface.
3. Insert sorted and randomized datasets into BST and AVL Trees.
4. Time the insertion and search operations for BST and AVL Trees.
5. Graph and analyze the insertion and search operation timings.

## Invocation and I/O Files:

The name of the program is `Proj2` ( provided with a `main` method in`Proj2.java` ). 

You are encouraged to run and debug code in __IntelliJ IDEA__. Also, the program can be invoked from the command-line as:

```shell
java Proj2 {dataset-file} {number of lines}
```

## 1. **Generic BST with Iterator Interface**

You already created Node and BST classes with a Comparable Interface for Project 1. If your implementation is perfect, you can simply copy over your files and continue to the next section. However, you can make whatever modifications that you deem necessary to complete this project.

## 2. **Generic AVL Tree Interface**

I have enclosed three starter codes:
1. `AvlTree.java`
2. `TestAvl.java`
3. `Proj2.java`

The `AvlTree.java` file contains an overall structure of that AVL Tree class, and you are expected to complete the code where it is indicated (Search for `// FINISH ME`). The `TestAvl.java` file must not be modified, and it will be used for testing your AVL Tree class. It does not check for every error, but I hope that it will be helpful for you. The `Proj2.java` file contains a starter code for you to implement the main driver of the program.

## 3. **Sorted and Randomized Datasets for BST and AVL Trees**

You already created a well-written class to store the records from a dataset for Project 1. If your dataset and implementation is perfect, you can simply copy over your files. However, you can make whatever modifications that you deem necessary to complete this project, and you can also choose a completely different dataset. The source of the dataset and modifications made to it must be documented inside the class.

I have enclosed `Proj2.java` that takes in two command line arguments: 1) the filename if your dataset, and 2) the number of lines of your dataset to read. 

You will read your dataset and store the data in an ArrayList. To sort and randomize your ArrayList, you will use the `Collections.sort()` and `Collections.shuffle()` commands.

You will then insert each element if your sorted and randomized ArrayLists into BST and AVL Trees. In total, there will be four trees.

You will then use your original ArrayList to search for each element in your BST and AVL Trees. In total, you will be searching four times.

## 4. **Time the Insertion and Search operations for BST and AVL Trees**

For each of the insertion and search operations, you will use `System.nanoTime()` to calculate the time it takes to run the insertion and search operations for the sorted and randomized BST and AVL Trees. Your program will print out the number of lines and the times to insert and search for BST and AVL Trees to the screen in a human-readable format (i.e., nice to look at) and also separtely to a file named `output.txt` in CSV format. Each time the program runs, it will append the timing results to `output.txt`.

## 5. Graph and analyze the insertion and search operation for BST and AVL Trees**

Run your program several times for different number of lines of your dataset, N, by choosing different values of the second command line argument. After several runs, your `output.txt` file will be filled with timing data.

Using your favorite graphing software (e.g., MS Excel or Google Sheets), plot the running time (in seconds) and rate (in seconds per node) vs. N for each case, comparing the BST and AVL Trees (i.e., two lines per graph). Take a screenshot of your graph and put them here by modifying this file, committing, and pushing it to this repository.

BST vs. AVL Tree running time (insertion):
(insert here)
<img width="600" height="373" alt="CSCGraph1a" src="https://github.com/user-attachments/assets/d05110e2-ed08-4f80-a2e4-e98b028b053c" />
<img width="600" height="370" alt="CSCGraph1b" src="https://github.com/user-attachments/assets/82149702-01ad-44d9-959d-61853f692050" />


BST vs. AVL Tree running time (search):
(insert here)
<img width="598" height="366" alt="CSCGraph2a" src="https://github.com/user-attachments/assets/414e7d07-ba91-4b1f-8c5b-3b8e2dcb5102" />
<img width="599" height="371" alt="CSCGraph2b" src="https://github.com/user-attachments/assets/50bed5fb-cb90-46ec-aaf1-eb2936e7ed18" />


BST vs. AVL Tree running rate (insertion):
(insert here)
<img width="601" height="369" alt="CSCGraph3a" src="https://github.com/user-attachments/assets/12e4cec6-d5a0-435c-b3b7-41d434f95c33" />
<img width="598" height="368" alt="CSCGraph3b" src="https://github.com/user-attachments/assets/0b2f9053-e563-4b93-9264-6b8bce66649c" />


BST vs. AVL Tree running rate (search):
(insert here)
<img width="599" height="370" alt="CSCGraph4a" src="https://github.com/user-attachments/assets/e613dbc2-2881-4266-8cc4-b584c18a8f36" />
<img width="597" height="367" alt="CSCGraph4b" src="https://github.com/user-attachments/assets/f06b434b-3775-4113-b354-42116e9e777c" />

Patterns amongst the trees:
For each of the randomized graphs, BST and AVL tree running times and running rates are about the same. For each of the sorted graphs, BST trees are worse for both running time and running rate.


## Submission:

Your project will be developed and graded via GitHub. Your final "push" is your final submission, and it must occur before it is due. On Canvas, enter the url to your Github repository. Your project will not be graded without it.

## Recommendations:

I ___strongly suggest___ that you carefully think through your strategy before just jumping into the code.  Once that is working, start adding in new features individually.  A good place to start is building your class.

*In order to get full points of Commenting and Code Style, you need to add comments to every methods and head comments for each file (providing file description, author, date, and acknowledgement).

```
/∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗*
∗ @file: filename.java
∗ @description: This program implements . . .
∗ @author: Your Name
∗ @date: October 21, 2025
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗/
```


Sources:

ChatGPT

Prompt:
here is an assignment for my data structures and algorithms class. We are comparing BST and AVL trees. Can you walk me through what it is asking me to do? I will then paste in the given files as well as the files it mentions from Project 1. 

Overview An AVL Tree is a type of self-balancing Binary Search Tree (BST) that ensures that the tree is approximately balanced. An AVL Tree remains balanced as elements are inserted or deleted. During class, we discussed the general algorithms for a BST and an AVL tree. In particular, we emphasized how a regular BST structure can become basically a linked list if its balance is not maintained, resulting in a O(N) running time instead of the O(log N) we expect from a properly balanced BST. In this project, you will: Implement a generic BST with an iterator interface. (You developed this in Project 1, which you can use as is or update.) Implement a generic AVL Tree with an iterator interface. Insert sorted and randomized datasets into BST and AVL Trees. Time the insertion and search operations for BST and AVL Trees. Graph and analyze the insertion and search operation timings. Invocation and I/O Files: The name of the program is Proj2 ( provided with a main method inProj2.java ). You are encouraged to run and debug code in IntelliJ IDEA. Also, the program can be invoked from the command-line as: java Proj2 {dataset-file} {number of lines} 1. Generic BST with Iterator Interface You already created Node and BST classes with a Comparable Interface for Project 1. If your implementation is perfect, you can simply copy over your files and continue to the next section. However, you can make whatever modifications that you deem necessary to complete this project. 2. Generic AVL Tree Interface I have enclosed three starter codes: AvlTree.java TestAvl.java Proj2.java The AvlTree.java file contains an overall structure of that AVL Tree class, and you are expected to complete the code where it is indicated (Search for // FINISH ME). The TestAvl.java file must not be modified, and it will be used for testing your AVL Tree class. It does not check for every error, but I hope that it will be helpful for you. The Proj2.java file contains a starter code for you to implement the main driver of the program. 3. Sorted and Randomized Datasets for BST and AVL Trees You already created a well-written class to store the records from a dataset for Project 1. If your dataset and implementation is perfect, you can simply copy over your files. However, you can make whatever modifications that you deem necessary to complete this project, and you can also choose a completely different dataset. The source of the dataset and modifications made to it must be documented inside the class. I have enclosed Proj2.java that takes in two command line arguments: 1) the filename if your dataset, and 2) the number of lines of your dataset to read. You will read your dataset and store the data in an ArrayList. To sort and randomize your ArrayList, you will use the Collections.sort() and Collections.shuffle() commands. You will then insert each element if your sorted and randomized ArrayLists into BST and AVL Trees. In total, there will be four trees. You will then use your original ArrayList to search for each element in your BST and AVL Trees. In total, you will be searching four times. 4. Time the Insertion and Search operations for BST and AVL Trees For each of the insertion and search operations, you will use System.nanoTime() to calculate the time it takes to run the insertion and search operations for the sorted and randomized BST and AVL Trees. Your program will print out the number of lines and the times to insert and search for BST and AVL Trees to the screen in a human-readable format (i.e., nice to look at) and also separtely to a file named output.txt in CSV format. Each time the program runs, it will append the timing results to output.txt. 5. Graph and analyze the insertion and search operation for BST and AVL Trees** Run your program several times for different number of lines of your dataset, N, by choosing different values of the second command line argument. After several runs, your output.txt file will be filled with timing data. Using your favorite graphing software (e.g., MS Excel or Google Sheets), plot the running time (in seconds) and rate (in seconds per node) vs. N for each case, comparing the BST and AVL Trees (i.e., two lines per graph). Take a screenshot of your graph and put them here by modifying this file, committing, and pushing it to this repository. BST vs. AVL Tree running time (insertion): (insert here) BST vs. AVL Tree running time (search): (insert here) BST vs. AVL Tree running rate (insertion): (insert here) BST vs. AVL Tree running rate (search): (insert here)

Response:
<img width="780" height="696" alt="CSC1" src="https://github.com/user-attachments/assets/3b7ef162-5663-48b5-a3fb-18f69ebbfee1" />
<img width="762" height="626" alt="CSC2" src="https://github.com/user-attachments/assets/8e455b6a-dcac-47d4-ae7d-1ab04ce3895e" />
<img width="759" height="553" alt="CSC3" src="https://github.com/user-attachments/assets/73a16020-3b5e-4f2e-835e-0605a8bb59a5" />
<img width="791" height="702" alt="CSC4" src="https://github.com/user-attachments/assets/01db68db-6325-4278-8bfa-5eb72df9072f" />
<img width="780" height="552" alt="CSC5" src="https://github.com/user-attachments/assets/956b06be-a99f-4e54-a5c3-a14486eeca92" />
<img width="775" height="729" alt="CSC6" src="https://github.com/user-attachments/assets/6e9f2920-a0dc-4227-899c-925605a320a8" />
<img width="784" height="529" alt="CSC7" src="https://github.com/user-attachments/assets/cc9c96e1-ffe0-4e8e-832a-0610c72b543e" />
<img width="772" height="428" alt="CSC8" src="https://github.com/user-attachments/assets/45b84a93-9d78-41d9-a378-4cfb5e57d105" />


Assessment of usefulness:
This was very useful as it broke down the project into its different parts and explained what needed to be done. This also prepared ChatGPT for the next prompt which will give it the code and ask it to complete the steps of the project.


Prompt:

Here are all of the classes for this project. Can you edit/fill in the code for each class as needed?

 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; import java.util.Collections; public class Proj2 { public static void main(String[] args) throws IOException { // Use command line arguments to specify the input file if (args.length != 2) { System.err.println("Usage: java TestAvl <input file> <number of lines>"); System.exit(1); } String inputFileName = args[0]; int numLines = Integer.parseInt(args[1]); // For file input FileInputStream inputFileNameStream = null; Scanner inputFileNameScanner = null; // Open the input file inputFileNameStream = new FileInputStream(inputFileName); inputFileNameScanner = new Scanner(inputFileNameStream); // ignore first line inputFileNameScanner.nextLine(); 	// FINISH ME } } public class TestAvl { // Test program public static void main( String [ ] args ) { AvlTree<Integer> t = new AvlTree<>(); final int SMALL = 40; final int NUMS = 1000000; // must be even final int GAP = 37; System.out.println("Checking... (no more output means success)"); // inserts sequence of numbers "GAP" apart into AVL Tree for (int i = GAP; i != 0; i = (i + GAP) % NUMS) { // System.out.println( "INSERT: " + i ); t.insert(i); // checks the balance of the tree after insertion if (NUMS < SMALL) t.checkBalance(); } // removes odd numbers for (int i = 1; i < NUMS; i += 2) { // System.out.println( "REMOVE: " + i ); t.remove(i); if (NUMS < SMALL) t.checkBalance(); } // prints the AVL Tree if (NUMS < SMALL) t.printTree(); // checks to see that the minimum value is 2 and the maximum value is NUMS - 2 if (t.findMin() != 2 || t.findMax() != NUMS - 2) System.out.println("FindMin or FindMax error!"); // checks to see if the AVL Tree contains even numbers (it should!) for (int i = 2; i < NUMS; i += 2) if (!t.contains(i)) System.out.println("Find error1!"); // checks to see if the AVL Tree contains odd numbers (it shouldn't!) for (int i = 1; i < NUMS; i += 2) { if (t.contains(i)) System.out.println("Find error2!"); } } } // AvlTree class // // CONSTRUCTION: with no initializer // // ******************PUBLIC OPERATIONS********************* // void insert( x ) --> Insert x // void remove( x ) --> Remove x (unimplemented) // boolean contains( x ) --> Return true if x is present // boolean remove( x ) --> Return true if x was present // Comparable findMin( ) --> Return smallest item // Comparable findMax( ) --> Return largest item // boolean isEmpty( ) --> Return true if empty; else false // void makeEmpty( ) --> Remove all items // void printTree( ) --> Print tree in sorted order // ******************ERRORS******************************** // Throws UnderflowException as appropriate /** * Implements an AVL tree. * Note that all "matching" is based on the compareTo method. */ public class AvlTree<AnyType extends Comparable<? super AnyType>> { /** * Construct the tree. */ public AvlTree( ) { root = null; } /** * Insert into the tree; duplicates are ignored. * @param x the item to insert. */ public void insert( AnyType x ) { root = insert( x, root ); } /** * Remove from the tree. Nothing is done if x is not found. * @param x the item to remove. */ public void remove( AnyType x ) { root = remove( x, root ); } /** * Internal method to remove from a subtree. * @param x the item to remove. * @param t the node that roots the subtree. * @return the new root of the subtree. */ private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t ) { 	// FINISH ME } /** * Find the smallest item in the tree. * @return smallest item or null if empty. */ public AnyType findMin( ) { if( isEmpty( ) ) throw new UnderflowException( ); return findMin( root ).element; } /** * Find the largest item in the tree. * @return the largest item of null if empty. */ public AnyType findMax( ) { if( isEmpty( ) ) throw new UnderflowException( ); return findMax( root ).element; } /** * Find an item in the tree. * @param x the item to search for. * @return true if x is found. */ public boolean contains( AnyType x ) { return contains( x, root ); } /** * Make the tree logically empty. */ public void makeEmpty( ) { root = null; } /** * Test if the tree is logically empty. * @return true if empty, false otherwise. */ public boolean isEmpty( ) { return root == null; } /** * Print the tree contents in sorted order. */ public void printTree( ) { if( isEmpty( ) ) System.out.println( "Empty tree" ); else printTree( root ); } private static final int ALLOWED_IMBALANCE = 1; // Assume t is either balanced or within one of being balanced private AvlNode<AnyType> balance( AvlNode<AnyType> t ) { 	// FINISH ME } public void checkBalance( ) { checkBalance( root ); } private int checkBalance( AvlNode<AnyType> t ) { if( t == null ) return -1; if( t != null ) { int hl = checkBalance( t.left ); int hr = checkBalance( t.right ); if( Math.abs( height( t.left ) - height( t.right ) ) > 1 || height( t.left ) != hl || height( t.right ) != hr ) System.out.println( "OOPS!!" ); } return height( t ); } /** * Internal method to insert into a subtree. * @param x the item to insert. * @param t the node that roots the subtree. * @return the new root of the subtree. */ private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t ) { 	// FINISH ME } /** * Internal method to find the smallest item in a subtree. * @param t the node that roots the tree. * @return node containing the smallest item. */ private AvlNode<AnyType> findMin( AvlNode<AnyType> t ) { 	// FINISH ME } /** * Internal method to find the largest item in a subtree. * @param t the node that roots the tree. * @return node containing the largest item. */ private AvlNode<AnyType> findMax( AvlNode<AnyType> t ) { 	// FINISH ME } /** * Internal method to find an item in a subtree. * @param x is item to search for. * @param t the node that roots the tree. * @return true if x is found in subtree. */ private boolean contains( AnyType x, AvlNode<AnyType> t ) { 	// FINISH ME } /** * Internal method to print a subtree in (sorted) order. * @param t the node that roots the tree. */ private void printTree( AvlNode<AnyType> t ) { 	// FINISH ME } /** * Return the height of node t, or -1, if null. */ private int height( AvlNode<AnyType> t ) { return t == null ? -1 : t.height; } /** * Rotate binary tree node with left child. * For AVL trees, this is a single rotation for case 1. * Update heights, then return new root. */ private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 ) { 	// FINISH ME } /** * Rotate binary tree node with right child. * For AVL trees, this is a single rotation for case 4. * Update heights, then return new root. */ private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 ) { 	// FINISH ME } /** * Double rotate binary tree node: first left child * with its right child; then node k3 with new left child. * For AVL trees, this is a double rotation for case 2. * Update heights, then return new root. */ private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 ) { 	// FINISH ME } /** * Double rotate binary tree node: first right child * with its left child; then node k1 with new right child. * For AVL trees, this is a double rotation for case 3. * Update heights, then return new root. */ private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 ) { 	// FINISH ME } private static class AvlNode<AnyType> { // Constructors AvlNode( AnyType theElement ) { this( theElement, null, null ); } AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt ) { element = theElement; left = lt; right = rt; height = 0; } AnyType element; // The data in the node AvlNode<AnyType> left; // Left child AvlNode<AnyType> right; // Right child int height; // Height } /** The tree root. */ private AvlNode<AnyType> root; } import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.util.*; // BST class that implements comparable and iterable with methods to clear, insert, search, remove, and print in order public class BST<T extends Comparable<T>> implements Iterable<T> { // private fields private Node<T> root; private int size = 0; // iterator class private class BSTIterator implements Iterator<T> { private Stack<Node<T>> stack = new Stack<>(); // constructor public BSTIterator() { Node<T> curr = root; // push all left nodes while (curr != null) { stack.push(curr); curr = curr.getLeft(); } } // returns the next smallest element in the stack @Override public T next() { //check if hasNext() if (!hasNext()) { throw new NoSuchElementException("Iter exceeded"); } Node<T> node = stack.pop(); T value = node.getData(); Node<T> curr = node.getRight(); // push all left nodes from the right child while(curr != null) { stack.push(curr); curr = curr.getLeft(); } return value; } // check if stack is empty @Override public boolean hasNext() { return !stack.isEmpty(); } } @Override public Iterator<T> iterator() { return new BSTIterator(); } // inserts the inputted value into the BST public Node<T> insertNode(T data) { Node<T> newNode = new Node<>(data); // if tree is empty, inserted node becomes the root if (root == null) { root = newNode; size = size + 1; return newNode; } Node<T> curr = root; Node<T> parent = null; // move down the tree according to the compare values to find insertion spot while (curr != null) { parent = curr; int compare = data.compareTo(curr.getData()); if (compare < 0) { curr = curr.getLeft(); } else if (compare > 0) { curr = curr.getRight(); } else { return curr; } } // compare inputted data value to value of current node to figure out which side to insert new node if (data.compareTo(parent.getData()) < 0) { parent.setLeft(newNode); } else { parent.setRight(newNode); } size = size + 1; return newNode; } // searches BST for node with inputted value and returns that node or null public Node<T> searchNode(T data) { Node<T> curr = root; // moves down tree accordingly and returns node if found while (curr!= null) { int compare = data.compareTo(curr.getData()); if (compare < 0) { curr = curr.getLeft(); } else if (compare > 0) { curr = curr.getRight(); } else { return curr; } } // returns null if not found return null; } // removes the node with the inputted value and adjusts the tree to account for the deletion public Node<T> removeNode(T data) { Node<T> curr = root; Node<T> parent = null; // move down tree until node with inputted value is found while (curr != null) { int compare = data.compareTo(curr.getData()); if (compare < 0) { parent = curr; curr = curr.getLeft(); } else if (compare > 0) { parent = curr; curr = curr.getRight(); } else { // node found because compare value is 0 break; } } // node not found if (curr == null) { return null; } // case 1: no children if (curr.getLeft() == null && curr.getRight() == null) { if (parent == null) { // node to remove is the root -> make root null (empty tree) root = null; // removes node by setting it to null } else if (parent.getLeft() == curr) { parent.setLeft(null); } else { parent.setRight(null); } size = size - 1; return curr; } // case 2: only child // only a right child if (curr.getLeft() == null && curr.getRight() != null) { if (parent == null) { // sets the right child to new root root = curr.getRight(); } else if (parent.getLeft() == curr) { // sets parent's left to the removed node's right child parent.setLeft(curr.getRight()); } else { // sets the parent's right to the removed node's right child parent.setRight(curr.getRight()); } size = size -1; return curr; } // only a left child if (curr.getLeft() != null && curr.getRight() == null) { if (parent == null) { // sets the left child to new root root = curr.getLeft(); } else if (parent.getLeft() == curr) { // sets parent's left to the removed node's left child parent.setLeft(curr.getLeft()); } else { // sets parent's right to the removed node's left child parent.setRight(curr.getLeft()); } size = size - 1; return curr; } // case 3: two children // create successor which will be the smallest node in right subtree Node<T> successorParent = curr; Node<T> successor = curr.getRight(); // find leftmost value in right subtree while (successor.getLeft() != null) { successorParent = successor; successor = successor.getLeft(); } // give the current node's data the data from the successor (replaces/removes the node with inputted value) curr.setData(successor.getData()); // rearrange the tree after moving the successor node if (successorParent.getLeft() == successor) { successorParent.setLeft(successor.getRight()); } else { successorParent.setRight(successor.getRight()); } size = size - 1; return curr; } // prints BST contents in ascending order to the result.txt file public void print(String fileName) { try(BufferedWriter bw = new BufferedWriter(new FileWriter(fileName, true))) { Iterator<T> iter = this.iterator(); // prints elements with spaces in between while (iter.hasNext()) { T value = iter.next(); bw.write(value.toString()); bw.newLine(); } } catch (IOException e) { System.out.println("IOException"); } } // clears the tree by setting root to null public void clear() { root = null; size = 0; } // returns size of BST public int size() { return size; } } public class Node<T extends Comparable<T>> { // private fields private T data; private Node<T> left; private Node<T> right; // constructor public Node(T data) { this.data = data; this.left = null; this.right = null; } // getters public T getData() { return data; } public Node<T> getLeft() { return left; } public Node<T> getRight() { return right; } // setters public void setData(T data) { this.data = data; } public void setLeft(Node<T> left) { this.left = left; } public void setRight(Node<T> right) { this.right = right; } // isLeaf method public boolean isLead() { return (getLeft() == null && getRight() == null); } } public class Song implements Comparable<Song> { // private fields private String id; private String name; private double duration; private double energy; private int key; private double loudness; private int mode; private double speechiness; private double acousticness; private double instrumentalness; private double liveness; private double valence; private double tempo; private double danceability; // default constructor public Song() { this.id = ""; this.name = ""; this.duration = 0.0; this.energy = 0.0; this.key = 0; this.loudness = 0.0; this.mode = 0; this.speechiness = 0.0; this.acousticness = 0.0; this.instrumentalness = 0.0; this.liveness = 0.0; this.valence = 0.0; this.tempo = 0.0; this.danceability = 0.0; } // parametrized constructor public Song(String id, String name, double duration, double energy, int key, double loudness, int mode, double speechiness, double acousticness, double instrumentalness, double liveness, double valence, double tempo, double danceability) { this.id = id; this.name = name; this.duration = duration; this.energy = energy; this.key = key; this.loudness = loudness; this.mode = mode; this.speechiness = speechiness; this.acousticness = acousticness; this.instrumentalness = instrumentalness; this.liveness = liveness; this.valence = valence; this.tempo = tempo; this.danceability = danceability; } // copy constructor public Song(Song copy) { this.id = copy.id; this.name = copy.name; this.duration = copy.duration; this.energy = copy.energy; this.key = copy.key; this.loudness = copy.loudness; this.mode = copy.mode; this.speechiness = copy.speechiness; this.acousticness = copy.acousticness; this.instrumentalness = copy.instrumentalness; this.liveness = copy.liveness; this.valence = copy.valence; this.tempo = copy.tempo; this.danceability = copy.danceability; } // getters public String getId() { return id; } public String getName() { return name; } public double getDuration() { return duration; } public double getEnergy() { return energy; } public int getKey() { return key; } public double getLoudness() { return loudness; } public int getMode() { return mode; } public double getSpeechiness() { return speechiness; } public double getAcousticness() { return acousticness; } public double getInstrumentalness() { return instrumentalness; } public double getLiveness() { return liveness; } public double getValence() { return valence; } public double getTempo() { return tempo; } public double getDanceability() { return danceability; } // setters public void setId(String id) { this.id = id; } public void setName(String name) { this.name = name; } public void setDuration(double duration) { this.duration = duration; } public void setEnergy(double energy) { this.energy = energy; } public void setKey(int key) { this.key = key; } public void setLoudness(double loudness) { this.loudness = loudness; } public void setMode(int mode) { this.mode = mode; } public void setSpeechiness(double speechiness) { this.speechiness = speechiness; } public void setAcousticness(double acousticness) { this.acousticness = acousticness; } public void setInstrumentalness(double instrumentalness) { this.instrumentalness = instrumentalness; } public void setLiveness(double liveness) { this.liveness = liveness; } public void setValence(double valence) { this.valence = valence; } public void setTempo(double tempo) { this.tempo = tempo; } public void setDanceability(double danceability) { this.danceability = danceability; } // puts values of a song to string @Override public String toString() { return id + "," + name + "," + duration + "," + energy + "," + key + "," + loudness + "," + mode + "," + speechiness + "," + acousticness + "," + instrumentalness + "," + liveness + "," + valence + "," + tempo + "," + danceability; } // checks if two objects are equal @Override public boolean equals(Object obj) { // checks if objects are in same location if (this == obj) { return true; } // check object type if (!(obj instanceof Song)) { return false; } Song other = (Song) obj; // compares the id and name values for equality return this.id == other.id && this.name.equals(other.name); } // compares the name of two songs @Override public int compareTo(Song other) { return this.name.compareToIgnoreCase(other.name); } } public class UnderflowException extends RuntimeException { public UnderflowException() { super(); } public UnderflowException(String message) { super(message); } }

Response:
<img width="779" height="716" alt="CSC9" src="https://github.com/user-attachments/assets/ca9507c1-7cf3-4bf7-8c30-fa6fa1615ff0" />
<img width="696" height="721" alt="CSC10" src="https://github.com/user-attachments/assets/8277eaaa-4bfb-4a6e-a69e-6849fe705bf9" />
<img width="681" height="716" alt="CSC11" src="https://github.com/user-attachments/assets/055edb6e-0966-4883-a0b0-8fed84649144" />
<img width="753" height="721" alt="CSC12" src="https://github.com/user-attachments/assets/f319b6d2-7ece-441c-a0fb-c9be288b82e4" />
<img width="728" height="720" alt="CSC13" src="https://github.com/user-attachments/assets/fce3ef68-ff2a-482d-b769-47eea5f971fc" />
<img width="729" height="721" alt="CSC14" src="https://github.com/user-attachments/assets/5cbe5fb5-b9cf-4687-b07d-64f788f5e8ff" />
<img width="761" height="714" alt="CSC15" src="https://github.com/user-attachments/assets/913c946d-401f-4f03-b342-fa2f5f1a7327" />
<img width="756" height="701" alt="CSC16" src="https://github.com/user-attachments/assets/7f6e038e-6010-477f-85c5-05bd24b990a2" />
<img width="760" height="732" alt="CSC17" src="https://github.com/user-attachments/assets/a631ccb7-d9a8-4469-8823-dd0c648c4ea8" />
<img width="744" height="745" alt="CSC18" src="https://github.com/user-attachments/assets/56553799-e1ce-4314-8894-fb41f56cbd32" />
<img width="728" height="748" alt="CSC19" src="https://github.com/user-attachments/assets/25ca81bc-6c2b-4fc5-9230-c597a25ab57b" />
<img width="715" height="726" alt="CSC20" src="https://github.com/user-attachments/assets/895026c3-23e9-487f-87dd-07095c1718aa" />
<img width="726" height="721" alt="CSC21" src="https://github.com/user-attachments/assets/2d1ba5f9-b2fa-468d-89fd-690f3b52c432" />
<img width="722" height="742" alt="CSC22" src="https://github.com/user-attachments/assets/f0e682a2-8222-47f5-83dc-d9b37929ab8b" />
<img width="732" height="744" alt="CSC23" src="https://github.com/user-attachments/assets/586e7605-cd26-4c43-8581-d18348672450" />
<img width="731" height="682" alt="CSC24" src="https://github.com/user-attachments/assets/b93d0f64-e5e6-4996-85ca-cdc0a7aec94f" />
<img width="773" height="704" alt="CSC25" src="https://github.com/user-attachments/assets/7c427a50-b891-4b2c-abe7-1eb5507b4652" />
<img width="773" height="427" alt="CSC26" src="https://github.com/user-attachments/assets/c76bb54c-a004-494f-aa58-e53ecd33ed14" />

Assessment of usefulness:
This was very useful as it successfully completed the classes that needed to be filled in. It also let me know which classes were already done and didn't need any chnages. Lastly, it pointed out a tiny error within both my Node class and my Song class that I was able to then fix. 

